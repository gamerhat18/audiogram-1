(require '[overtone.live :as overtone])

; Simple sine wave
(overtone/definst sine-wave [freq 440 attack 0.01 sustain 1.0 release 0.1 vol 0.4]
  (* (overtone/env-gen (overtone/lin-env attack sustain release) 1 1 0 1 overtone/FREE)
     (overtone/sin-osc freq)
     vol))

; Range of frequencies a normal human can hear, from 12Hz to 20kHz.  We make a step in 500Hz
; to make the range reasonable.
(def audible-frequencies (range 125 20000 2000))

; Convenience and helper functions
(defn mean [a b] (quot (+ a b) 2))

; We can determine the volume at which a frequency becomes audible by bisecting the range of
; volumes, increasing or decreasing based on the response at the chosen volume.  So first
; we need a function that will bisect a range based on the result of another function.
(defn bisect [decider-fn initial-first-of-range initial-last-of-range]
  (loop [first-of-range initial-first-of-range
         last-of-range  initial-last-of-range]
    (let [mid-of-range  (mean first-of-range last-of-range)]
      (if (or (= first-of-range mid-of-range) (= last-of-range mid-of-range))
        first-of-range
        (if (decider-fn mid-of-range)
          (recur first-of-range mid-of-range)
          (recur mid-of-range last-of-range)))
      )))

(require '[clojure.core.async :as async])

; This function plays a tone at a given frequency and volume.  It does this asynchronously
; so it actually returns a channel.  Once the tone has finished playing 'false' is sent
; on the channel to indicate that the tone was not interrupted.
;
; Overtone is asynchronous, so the tone is played and this would normally return immediately.
; Thankfully we can simply use core.async/timer to deal with that
(defn tone-player [frequency volume duration]
  (let [ch (async/chan)]
    (async/go
      (sine-wave {:freq frequency :vol volume :sustain duration})
      (async/<!! (async/timeout (* duration 2)))
      (async/>! ch false))
    ch))

; This function determines if the user has pressed a key, indicating that they have heard
; the tone.  This is done asynchronously so this function actually returns a channel.
; 'true' is sent on the channel to indicate that the user pressed the key.
(defn hearing-user []
  (let [ch (async/chan)]
    (async/go
      (read-line)
      (async/>! ch true))
    ch))

; Now we need a decider-fn for the bisect call that will take a given value and play the
; frequency at that volume for a period of time.  If the user responds before the tone
; finishes playing we can assume that they heard it, otherwise we assume they did not.
; If they have heard it we stop the tone in preparation for the next one.
;
; Essentially our problem is now one of waiting on the response from one of two channels.
(defn bisect-fn-for-frequency [frequency]
  (fn [integer-volume]
    (let [tone-done (tone-player frequency (/ integer-volume 100000.0) 5.0)
          user-done (hearing-user)]
      (first (async/alts!! [tone-done user-done])))))

; The audiogram is now generated by mapping over all of the audible frequencies to find the
; volume at which the user can hear them, which will generate a sequence of pairs.  Note that
; this is lazy, so it's only once we actually have to use the audiogram that we actually have
; to generate it.
(def audiogram
  (map
    (fn [frequency] [frequency (bisect (bisect-fn-for-frequency frequency) 0 100000)])
    audible-frequencies))
